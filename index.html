<!DOCTYPE html>
<html lang="en">

<head>
    <title>SPACE Three.JS</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="css/basic.css">

    <script src="three.js"></script>
    <script src="js/Detector.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script type="text/javascript">


        // Checks that your browser supports WebGL. 
        if (!Detector.webgl) Detector.addGetWebGLMessage();

        var renderer = null;
        var scene = null;
        var camera = null;
        var piano = null;
        var piano_group = null;
        var earth = null;
        var moon = null;
        var solar_sys = null;
        var moon_group = null;
        var mars = null;
        var cameraAngle = null;
        var curTime = Date.now();
        var key_grp = null;

        // This function is called whenever the document is loaded
        function init() {


            // Get display canvas
            var canvas = document.getElementById("webglcanvas");
            console.log(canvas);

            // Create the Three.js renderer and attach it to our canvas
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true
            });
            // Set the viewport size
            renderer.setSize(canvas.width, canvas.height);
            // Create a new Three.js scene
            scene = new THREE.Scene();
            // scene.background = new THREE.TextureLoader().load( 'images/MilkyWay/posy.jpg' );
            // Add  a camera so we can view the scene
            camera = new THREE.PerspectiveCamera(45, canvas.width / canvas.height,
                1, 4000);

            camera.position.z = 20;


            //  Create the sun map & geometry
            var piano = new THREE.MeshBasicMaterial({ color: 0xffffff });
            var key2color = new THREE.MeshBasicMaterial({ color: 0xf1ff });
            var geometry = new THREE.CubeGeometry(5, 1, 2);

            key1 = new THREE.Mesh(geometry, piano);
            key1.position.set(0, 0, 0);
            key1.rotation.y = Math.PI / 2;

            key2 = new THREE.Mesh(geometry, key2color);
            key2.position.set(2, 0, 0);
            key2.rotation.y = Math.PI / 2;

            key3 = new THREE.Mesh(geometry, piano);
            key3.position.set(4, 0, 0);
            key3.rotation.y = Math.PI / 2;

            key4 = new THREE.Mesh(geometry, key2color);
            key4.position.set(6, 0, 0);
            key4.rotation.y = Math.PI / 2;





            /// GROUPS ---------------------------------------------


            /// K1 -----
            key_rot1 = new THREE.Group();
            key_rot1.add(key1);

            key_group1 = new THREE.Group();
            key_group1.add(key_rot1);
            key_group1.position.set(-2.5, 0.5, 2.5);

            real_k1 = new THREE.Group();
            real_k1.add(key_group1)
            real_k1.position.set(0, 0, 0);


            /// K2 ----------

            key_rot2 = new THREE.Group();
            key_rot2.add(key2);

            key_group2 = new THREE.Group();
            key_group2.add(key_rot2);
            key_group2.position.set(-2.5, 0.5, 2.5);

            real_k2 = new THREE.Group();
            real_k2.add(key_group2)
            real_k2.position.set(0, 0, 0);


            /// K3 -------------
            key_rot3 = new THREE.Group();
            key_rot3.add(key3);

            key_group3 = new THREE.Group();
            key_group3.add(key_rot3);
            key_group3.position.set(-2.5, 0.5, 2.5);

            real_k3 = new THREE.Group();
            real_k3.add(key_group3)
            real_k3.position.set(0, 0, 0);





            /// CAMERA CONTROLS ------------------------------------------

            controls = new THREE.OrbitControls(camera, renderer.domElement,);

            //controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)
            controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
            controls.dampingFactor = 0.25;
            controls.screenSpacePanning = false;
            controls.minDistance = 1;
            controls.maxDistance = 20;

            // Finally, add the mesh to our scene
            //scene.add(piano_group);
            scene.add(real_k1);
            scene.add(real_k2);
            scene.add(real_k3);
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);

            var contexteAudio = new (window.AudioContext || window.webkitAudioContext)();

            // create Oscillator node
            var oscillator = contexteAudio.createOscillator();
            oscillator.type = 'square';
            oscillator.start()

            const sleep = ms => new Promise(r => setTimeout(r, ms));

            async function soundNote(osc, container, freq) {
                oscillator.frequency.value = freq; // valeur en hertz
                osc.connect(contexteAudio.destination);
                await sleep(200);
                osc.disconnect();
                container.rotation.x = 0;
            }

            document.addEventListener("keydown", setupKeyControls, false);
            function setupKeyControls(e) {
                var cube = scene.getObjectByName('cube');
                switch (e.keyCode) {
                    case 65:
                        real_k1.rotation.x += 0.1;
                        soundNote(oscillator, real_k1, 440);
                        break;
                    case 90:
                        real_k2.rotation.x += 0.1;
                        soundNote(oscillator, real_k2, 220);
                        break;
                }
            }

        }

        // This function is called regularly to update the canvas webgl.
        function run() {
            // Ask to call again run 
            requestAnimationFrame(run);

            // Render the scene
            render();

            // Calls the animate function if objects or camera should move
            animate();
        }

        // This function is called regularly to take care of the rendering.
        function render() {
            // Render the scene
            renderer.render(scene, camera);
        }

        // This function is called regularly to update objects.
        function animate() {

            // Computes how time has changed since last display
            var now = Date.now();
            var deltaTime = now - curTime;
            curTime = now;
            var fracTime = deltaTime / 1000; // in seconds
            // Now we can move objects, camera, etc.
            // Example: rotation cube
            var angle = 0.1 * Math.PI * 2 * fracTime; // one turn per 10 second.
            var angleR = fracTime * Math.PI * 2;

        }




    </script>
</head>

<body>
    <div id="info"> ThreeJS app will become space invader ? </div>
    <canvas id="webglcanvas" style="border: none;background-color:#000000" width="1920" height="1080"></canvas>
    <!-- We run the WebGL code at the end to be sure that the document is loaded.
      -->
    <script>
        // We put the starting point of the javascript here, so that the whole page
        // is loaded before WebGL code is executed.
        init(); run();
    </script>
</body>

</html>